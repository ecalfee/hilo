## ancestry_by_r/Snakefile: pipeline to get global ancestry estimates by recombination quintile (and bootstrap results)

workdir: path_hilo
# note: working directory is hilo/ and all file inputs/outputs below are relative to that working directory

## make_coding_bed: makes a bed file of coding regions ('CDS') from gff3 file. merges overlapping CDS and sorts results by genome order.
rule make_coding_bed:
    input:
        annotations = ref_anno,
        genome = ref_chr
    output:
        bed = "data/refMaize/geneAnnotations/Zea_mays.B73_RefGen_v4.41.chr.CDS.bed"
    params:
        p = "med2"
    shadow:
         "minimal"
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = 5,
        mem = 4
    shell:
        """
        grep -v '^#' {input.annotations} | awk -v OFS='\\t' '{{print $1,$4,$5,$3}}' |\\
        grep 'CDS' | grep -v '^Mt' | grep -v '^Pt' |\\
        bedtools sort -faidx {input.genome} -i stdin |\\
        bedtools merge -i stdin -c 4 -o distinct > {output}
        """

## define_1cM_windows: divides genome into 1cM windows
rule define_1cM_windows:
    input:
        rmap = rmap_ext,
        genome = ref_chr,
        cds = "data/refMaize/geneAnnotations/Zea_mays.B73_RefGen_v4.41.chr.CDS.bed"
    output:
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt"
    params:
        p = "med2"
    shadow:
         "minimal"
    conda:
         "../envs/environment.yaml"
    resources:
         time_min = 15,
         mem = 2
    script:
         "define_1cM_windows_from_map.R" # define_bootstrap_windows_from_map.R

## sample_bootstrap_1cM: makes bootstrap (i.e. with replacement) samples of 1cM windows within recombination rate quintiles
rule sample_bootstrap_1cM:
    input:
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt"
    output: # FEATURE is recombination rate cM/Mb (r), coding bp/cM (cd), or frac coding bp (frac)
        expand("ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{{FEATURE}}5_{r}/boot{BOOT}.list",
        r = [1, 2, 3, 4, 5], BOOT = list(range(0,101))) # 5 recombination rate quintiles, '0' for original sample and 1-100 bootstrap samples
    params:
        p = "med2",
        n = 100, # 100 bootstraps
        prefix_all = prefix_all,
        feature = lambda wildcards: wildcards.FEATURE
    conda:
         "../envs/environment.yaml"
    resources:
         time_min = 15,
         mem = 2
    script:
         "sample_windows_4_bootstrap.R"

## make_bed_files_for_windows: makes a separate bed file for each 1cM window
rule make_bed_file_for_windows:
    input:
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt"
    output:
        expand("ancestry_by_r/results/BED_1cM/{WINDOW}.bed", WINDOW = windows_1cM)
    params:
        p = "med2",
        prefix_all = prefix_all
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = 5,
        mem = 2
    script:
        "make_bed_4_windows.R"

## find_SNPs_in_window: creates a GL file for each 1cM window using bedtools
# To accomplish this, I use an awk split file; first mapping the window label onto the GL line,
# then sending lines into each window-named file based on their 1cM window label
rule find_SNPs_in_window:
    input:
        gl = "global_ancestry/results/thinnedSNPs/" + prefix_all + "/whole_genome.beagle.gz",
        bed = "ancestry_by_r/results/BED_1cM/{WINDOW}.bed",
        genome = ref_chr
    output:
        "ancestry_by_r/results/GL_1cM/" + prefix_all + "/{WINDOW}.beagle.gz"
    params:
        p = "med2",
        prefix_all = prefix_all
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = lambda wildcards, attempt: attempt * 20,
        mem = lambda wildcards, attempt: attempt * 8
    shell:
        # get header and then append all the SNPs found within the window specified by the bed file
        "./ancestry_by_r/find_SNPs_in_window.sh {input.gl} {input.bed} {input.genome} {output}"

## make_bootstrap_GL_file: creates a new beagle GL file for a bootstrap sample by including SNPs within the sampled windows (with replacement)
rule make_bootstrap_GL_file:
    input:
        "global_ancestry/results/thinnedSNPs/" + prefix_all + "/whole_genome.beagle.gz",
        "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/boot{BOOT}.list",
        expand("ancestry_by_r/results/GL_1cM/" + prefix_all + "/{WINDOW}.beagle.gz", WINDOW = windows_1cM)
    output:
        "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/boot{BOOT}.beagle.gz"
    params:
        p = "med2",
        prefix_all = prefix_all,
        gl = lambda wildcards, input: input[0],
        sample = lambda wildcards, input: input[1]
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = lambda wildcards, attempt: attempt * 20,
        mem = lambda wildcards, attempt: attempt * 8
    shell:
        "./ancestry_by_r/make_bootstrap_GL_file.sh {params.gl} {params.sample} {params.prefix_all} {output}"

## run_bootstrap_NGSAdmix: runs NGSAdmix for a bootstrap sample
rule run_bootstrap_NGSAdmix:
    input:
        gl = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/boot{BOOT}.beagle.gz"
    output:
        admix = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/K2/boot{BOOT}.qopt"
    params:
        p = "med2",
        prefix_all = prefix_all,
        k = 2
    shadow:
         "minimal"
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = lambda wildcards, attempt: attempt * 30,
        mem = lambda wildcards, attempt: attempt * 4
    threads:
        1
    shell:
        """
        NGSadmix -likes {input.gl} \
        -K {params.k} -P {threads} \
        -o "ancestry_by_r/results/bootstrap_1cM/{params.prefix_all}/{wildcards.FEATURE}5_{wildcards.r}/K{params.k}/boot{wildcards.BOOT}"
        """

## label_k_anc: defines which of K ancestries is 'mexicana' based on allopatric reference panels
rule label_k_anc:
    input:
        admix = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/K2/boot{BOOT}.qopt",
        meta = "samples/HILO_MAIZE55_meta.RData"
    output:
        anc = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/K2/boot{BOOT}.anc"
    params:
        p = "med2",
        k = 2
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = 5,
        mem = 2
    script:
        "label_k_ancestries.R"

## summarise_bootstrap_anc_by_r: summarises bootstrap results for global ancestry by genomic quintiles
rule summarise_bootstrap_anc_by_r:
    input:
        "samples/HILO_MAIZE55_meta.RData", # can't have only some named inputs; can use [[1]] to access in R
        "ancestry_by_r/results/map_pos_1cM_windows.txt",
        expand("ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{{FEATURE}}5_{r}/K2/boot{BOOT}.anc",
        r = [1, 2, 3, 4, 5], BOOT = list(range(0, 101)))
    output:
        rdata = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_K2.Rdata"
    params:
        p = "med2",
        k = 2,
        prefix_all = prefix_all,
        feature = lambda wildcards: wildcards.FEATURE,
        meta = "samples/HILO_MAIZE55_meta.RData",
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt",
        alpha = 0.1 # use 90% confidence intervals for bootstrap
    conda:
         "../envs/environment.yaml"
    resources:
         time_min = 15,
         mem = 2
    script:
         "summarise_bootstrap_NGSadmix.R"

## map_local_anc_onto_1cM_windows: maps local ancestry results onto 1cM genomic windows based on ancestry tracts bed file
rule map_local_anc_onto_1cM_windows:
    input:
        anc = "local_ancestry/results/ancestry_hmm/" + prefix_all + "/Ne{Ne}_{YESNO}Boot/anc/{POP}.anc.freq",
        tracts = "local_ancestry/results/thinnedSNPs/" + prefix_all + "/whole_genome.bed", # defines ancestry tracts
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt" # 1cM windows
    output:
        bed = "ancestry_by_r/results/local_anc_1cM/" + prefix_all + "/Ne{Ne}_{YESNO}Boot/{POP}.bed"
    params:
        p = "med2"
    conda:
        "../envs/environment.yaml"
    resources:
        time_min = 10,
        mem = 2
    shell:
        """
        paste {input.tracts} {input.anc} | \\
        bedtools intersect -b {input.windows} -a stdin | \\
        bedtools sort | \\
        bedtools map -a stdin -b {input.windows} -c 4 -o distinct > {output.bed}
        """

## map_sites_onto_1cM_windows: maps sites onto 1cM windows
rule map_sites_onto_1cM_windows:
    input:
        tracts = "local_ancestry/results/thinnedSNPs/" + prefix_all + "/whole_genome.bed", # defines ancestry tracts
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt" # 1cM windows
    output:
        bed = "ancestry_by_r/results/local_anc_1cM/" + prefix_all + "/ancestry_hmm_sites.bed"
    params:
        p = "med2"
    conda:
        "../envs/environment.yaml"
    resources:
        time_min = 10,
        mem = 2
    shell:
        """
        awk {input.tracts} -v OFS='\\t' '{{print $1,$2-1,$2}}' | \\
        bedtools map -b {input.windows} -a stdin | \\
        bedtools sort > {output.bed}
        """

## summarise_local_anc_by_1cM: summarises mean local ancestry results by 1cM genomic windows
rule summarise_local_anc_by_1cM:
    input:
        bed = "ancestry_by_r/results/local_anc_1cM/" + prefix_all + "/Ne{Ne}_{YESNO}Boot/{POP}.bed",
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt" # 1cM windows
    output:
        summary = "ancestry_by_r/results/local_anc_1cM/" + prefix_all + "/Ne{Ne}_{YESNO}Boot/{POP}.anc.wind"
    params:
        p = "bigmemm",
        pop = lambda wildcards: wildcards.POP
    conda:
        "../envs/environment.yaml"
    resources:
        time_min = 5,
        mem = 2
    script:
        "summarise_local_anc_by_1cM.R"

## input_abba_baba: creates input size and bam_list for running abba baba (f4) calcs
## where POP is the focal population and ALLO_MEX is the allopatric mexicana reference group (either all allopatric_mexicana or just pop22)
rule input_abba_baba:
    input:
        parv_bams = "samples/ALL_byPop/parv_bams.list",
        mex_bams = "samples/ALL_byPop/{ALLO_MEX}_bams.list",
        x_bams = "samples/ALL_byPop/{POP}_bams.list",
        trip_bams = "samples/ALL_byPop/trip_bams.list"
    output:
        bam_list = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}_bams.list",
        pops_size = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}.size"
    params:
        p = "med2"
    resources:
        time_min = 1,
        mem = 1
    shell:
        """
        cat {input.parv_bams} {input.mex_bams} {input.x_bams} {input.trip_bams} > {output.bam_list}
        < {input.parv_bams} wc -l > {output.pops_size}
        < {input.mex_bams} wc -l >> {output.pops_size}
        < {input.x_bams} wc -l >> {output.pops_size}
        < {input.trip_bams} wc -l >> {output.pops_size}
        """

## get_region_from_bed(): helper function to extract region in format chr:start-end from a single region bed file
def get_region_from_bed(window):
    with open("ancestry_by_r/results/BED_1cM/" + window + ".bed") as f:
        line1 = f.readline()
        line2 = f.readline()
        row = line2.split("\t")
    return row[0] + ":" + row[1] + "-" + row[2]

## get_size_region_from_bed(): helper function to extract size of a region as an integer (# bp start-end) from a single region bed file
def get_size_region_from_bed(window):
    with open("ancestry_by_r/results/BED_1cM/" + window + ".bed") as f:
        line1 = f.readline()
        line2 = f.readline()
        row = line2.split("\t")
    return (int(row[2]) - int(row[1]))/1000000 # units Mbp

## do_abba_baba: runs angsd abba_baba2 to get f4 statistic for 1 genomic window
# output file has all possible population orders .. will later extract f4(parv, mex; x, trip)
rule do_abba_baba:
    input:
        bams = all_bams_parv_trip, # all input bams
        bais = [bam + ".bai" for bam in all_bams_parv_trip], # all input bam indexes
        bam_list = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}_bams.list",
        bed_window = "ancestry_by_r/results/BED_1cM/{WINDOW}.bed",
        pops_size = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}.size"
    output:
        abbababa = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}/{WINDOW}.abbababa2",
        sample_depth = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}/{WINDOW}.depthSample",
        global_depth = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}/{WINDOW}.depthGlobal"
    params:
        p = "med2",
        out_prefix = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}/{WINDOW}",
        region = lambda wildcards: get_region_from_bed(wildcards.WINDOW)
    shadow:
        "minimal"
    resources:
        time_min = lambda wildcards, attempt: attempt * 30 + int(get_size_region_from_bed(wildcards.WINDOW) * 3.5), # 1/2 hour to 4 hours for attempt 1
        mem = lambda wildcards, attempt: [8, 16, 48][attempt - 1] # 8G, 16G or 48G
    shell:
        "angsd -out {params.out_prefix} "
        "-doAbbababa2 1 "
        "-r {params.region} "
        "-bam {input.bam_list} "
        "-sizeFile {input.pops_size} "
        "-remove_bads 1 -minMapQ 30 -minQ 20 "
        "-doCounts 1 -doDepth 1 "
        "-maxDepth 10000 "
        "-useLast 1 "
        "-blockSize 60000000 "
        "-checkBamHeaders 0"

# -doAbbababa2 options: -maxDepth=max depth of each site allowed (default 100)
# -sizeFile = file with sizes of the populations
# -doCounts 1 = make counts (required)
# -useLast 1 = use the last group of bam files as outgroup (tripsacum)
# -blockSize should exceed LD, here I make it bigger than the largest 1cM window, but note that some windows are still split across blocks

## f4_from_abba_baba: extracts f4(parv, allo_mex; x, trip) from .abbababa2 output
# Each set of 3 lines represents one possible 4-pop tree. For the correct tree for f4-ratio estimates we take the
# 1st and every 3rd line. (some windows have more than 1 line because they spanned multiple 60Mbp chunks)
rule f4_from_abba_baba:
    input:
        expand("ancestry_by_r/results/f4_{{ALLO_MEX}}/{{POP}}/{WINDOW}.abbababa2", WINDOW = windows_1cM)
    output:
        f4 = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}.f4"
    params:
        p = "med2",
        POP = "{POP}",
        ALLO_MEX = "{ALLO_MEX}"
    conda:
        "../envs/environment.yaml"
    resources:
        time_min = 10,
        mem = 2
    shell:
        """
        (head -n 1 ancestry_by_r/results/f4_{params.ALLO_MEX}/{params.POP}/W1.abbababa2 | \\
        cut -f1-6 | awk -v OFS='\\t' '{{print "window",$0,"pop1","pop2","pop3","pop4"}}'
        for i in {{1..1520}}
        do tail -n +2 ancestry_by_r/results/f4_{params.ALLO_MEX}/{params.POP}/W$i.abbababa2 | \\
        cut -f1-6 | awk -v i=$i -v pop={params.POP} -v OFS='\\t' 'NR%3==1 {{print "W"i,$0,"parviglumis","allopatric_mexicana",pop,"tripsacum"}}'
        done) > {output.f4}
        """

## calc_and_plot_f4: calculates and plots f4 ratio for admixture proportion estimates (with bootstrap results)
rule calc_and_plot_f4:
    input:
        f4_num = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}.f4",
        f4_denom = "ancestry_by_r/results/f4_{ALLO_MEX}/allopatric_maize.f4",
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt",
        inv_file = "data/refMaize/inversions/knownInv_v4_coord.txt",
        colors = "colors.R"
    output:
        png_r5 = "ancestry_by_r/plots/f4_allo_{ALLO_MEX}_symp_{POP}_byr5.png",
        png_cd5 = "ancestry_by_r/plots/f4_allo_{ALLO_MEX}_symp_{POP}_bycd5.png",
        png_r5_no_inv4m = "ancestry_by_r/plots/f4_allo_{ALLO_MEX}_symp_{POP}_byr5_noinv4m.png",
        png_cd5_no_inv4m = "ancestry_by_r/plots/f4_allo_{ALLO_MEX}_symp_{POP}_bycd5_noinv4m.png",
        png_f4_num_denom = "ancestry_by_r/plots/f4_allo_{ALLO_MEX}_symp_{POP}_num_denom.png"
    params:
        p = "med2",
        sympatric_pop = "{POP}",
        n_boot = 1000
    conda:
        "../envs/environment.yaml"
    resources:
        time_min = 15,
        mem = 2
    script:
        "calc_and_plot_f4.R"


## combine_abba_baba_for_Dstat: combines .abbababa2 files across the genome for input to D-statistic calc
rule combine_abba_baba_for_Dstat:
    input:
        expand("ancestry_by_r/results/f4_{{ALLO_MEX}}/{{POP}}/{WINDOW}.abbababa2", WINDOW = windows_1cM)
    output:
        abbababa = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}.all.abbababa2",
        pop_names = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}.names"
    params:
        p = "med2",
        POP = "{POP}",
        ALLO_MEX = "{ALLO_MEX}"
    conda:
        "../envs/environment.yaml"
    resources:
        time_min = 10,
        mem = 2
    shell:
        """
        (cat ancestry_by_r/results/f4_{params.ALLO_MEX}/{params.POP}/W1.abbababa2
        for i in {2..1520}
        do tail -n +2 ancestry_by_r/results/f4_{params.ALLO_MEX}/{params.POP}/W$i.abbababa2
        done) > {output.abbababa}
        echo "parviglumis" > {output.pops_name}
        echo "allopatric_mexicana" >> {output.pops_name}
        echo {POP} >> {output.pops_name}
        echo "tripsacum" >> {output.pops_name}
        """

## calc_Dstat: calculates D-statistic genomewide with bootstrap confidence intervals
rule calc_Dstat:
    input:
        abbababa = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}.all.abbababa2",
        pops_name = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}.names",
        pops_size = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}.size"
    output:
        "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}.Dstats.Observed.txt"
    params:
        p = "med2",
        prefix_out = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}.Dstats",
        prefix_in = "ancestry_by_r/results/f4_{ALLO_MEX}/{POP}.all"
    conda:
        "../envs/environment.yaml"
    resources:
        time_min = 10,
        mem = 2
    shell:
        "Rscript ../software/angsd_0.932/R/estAvgError.R angsdFile={params.prefix_in} out={params.prefix_out} sizeFile={input.pops_size} nameFile={input.pops_name}"


## subsample_group: takes a random subsample (no-repeats) of bams from a group of bams
# rule subsample_group:
#     input:
#         all_bams = "samples/ALL_byPop/{GROUP}_bams.list"
#     output:
#         sub_bams = "samples/ALL_byPop/{GROUP}_subsample{SUBSAMPLE}_bams.list"
#     params:
#         p = "med2",
#         i = "{SUBSAMPLE}"
#     resources:
#         time_min = 1,
#         mem = 1
#     shell:
#         shuf -n {params.i} {input.all_bams} > {output.sub_bams}


## plot_bootstrap_anc_by_r: plots bootstrap results for global & local ancestry by recombination rate
rule plot_bootstrap_anc_by_r:
    input:
        colors = "colors.R",
        meta = "samples/HILO_MAIZE55_meta.RData",
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt",
        inv_file = "data/refMaize/inversions/knownInv_v4_coord.txt",
        r5 = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/r5_K2.Rdata",
        cd5 = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/cd5_K2.Rdata",
        local_anc = ["ancestry_by_r/results/local_anc_1cM/" + prefix_all + "/Ne10000_yesBoot/" + POP + ".anc.wind" for POP in symp_pops]
    output:
        png_r5_symp = "ancestry_by_r/plots/K2_by_r_bootstrap_sympatric_only.png",
        png_r5_symp_allo = "ancestry_by_r/plots/K2_by_r_bootstrap_sympatric_and_allopatric.png",
        png_cd5_symp = "ancestry_by_r/plots/K2_by_cd_bootstrap_sympatric_only.png",
        png_cd5_symp_allo = "ancestry_by_r/plots/K2_by_cd_bootstrap_sympatric_and_allopatric.png",
        png_cor_r_cd = "ancestry_by_r/plots/corr_r_cd_1cM.png",
        png_cor_r_frac = "ancestry_by_r/plots/corr_r_frac_1cM.png",
        png_facet_r5 = "ancestry_by_r/plots/K2_by_r_bootstrap_lm_elevation_facet_r.png",
        png_color_elev_r5 = "ancestry_by_r/plots/K2_by_r_bootstrap_lm_elevation_color_elev.png",
        png_r5_local_anc = "ancestry_by_r/plots/local_anc_by_r_sympatric_only.png",
        png_cd5_local_anc = "ancestry_by_r/plots/local_anc_by_cd_sympatric_only.png",
        png_boot_cor_local_anc_bp = "ancestry_by_r/plots/boot_cor_local_anc_bp.png",
        png_boot_cor_local_anc_r5 = "ancestry_by_r/plots/boot_cor_local_anc_r5.png"

    params:
        p = "med2",
        alpha = 0.05,
        dir_anc = "ancestry_by_r/results/local_anc_1cM/" + prefix_all + "/Ne10000_yesBoot"
    conda:
         "../envs/environment.yaml"
    resources:
         time_min = 5,
         mem = 4
    script:
         "plot_bootstrap_NGSadmix.R"
