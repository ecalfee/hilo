## ancestry_by_r/Snakefile: pipeline to get global ancestry estimates by recombination quintile (and bootstrap results)

workdir: path_hilo
# note: working directory is hilo/ and all file inputs/outputs below are relative to that working directory

## make_coding_bedfile: makes a bed file of coding regions ('CDS') from gff3 file. merges overlapping CDS and sorts results by genome order.
rule make_coding_bedfile:
    input:
        annotations = "data/refMaize/geneAnnotations/Zea_mays.B73_RefGen_v4.41.chr.gff3",
        genome = ref_chr
    output:
        bed = "data/refMaize/geneAnnotations/Zea_mays.B73_RefGen_v4.41.chr.CDS.bed"
    params:
        p = "med2"
    shadow:
         "minimal"
    conda:
         "../envs/environment.yaml"
    resources:
         time_min = 15,
         mem = 2
    shell:
        """
        grep -v '^#' {input} | awk '{{print $1"\t"$4"\t"$5"\t"$3}}' |\
        grep 'CDS' | grep -v '^Mt' | grep -v '^Pt' |\
        bedtools sort -faidx {input.genome} -i stdin |\
        bedtools merge -i stdin -c 4 -o distinct > {output}
        """

## define_1cM_windows: divides genome into 1cM windows
rule define_1cM_windows:
    input:
        rmap = rmap_ext,
        genome = ref_chr,
        cds = "data/refMaize/geneAnnotations/Zea_mays.B73_RefGen_v4.41.chr.CDS.bed"
    output:
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt"
    params:
        p = "med2"
    shadow:
         "minimal"
    conda:
         "../envs/environment.yaml"
    resources:
         time_min = 15,
         mem = 2
    script:
         "define_1cM_windows_from_map.R" # define_bootstrap_windows_from_map.R

## sample_bootstrap_1cM: makes bootstrap (i.e. with replacement) samples of 1cM windows within recombination rate quintiles
rule sample_bootstrap_1cM:
    input:
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt"
    output: # FEATURE is recombination rate cM/Mb (r), coding bp/cM (cd), or frac coding bp (frac)
        expand("ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{{FEATURE}}5_{r}/boot{BOOT}.list",
        r = [1, 2, 3, 4, 5], BOOT = list(range(0,101))) # 5 recombination rate quintiles, '0' for original sample and 1-100 bootstrap samples
    params:
        p = "med2",
        n = 100, # 100 bootstraps
        prefix_all = prefix_all,
        feature = lambda wildcards: wildcards.FEATURE
    conda:
         "../envs/environment.yaml"
    resources:
         time_min = 15,
         mem = 2
    script:
         "sample_windows_4_bootstrap.R"

## make_bed_files_for_windows: makes a separate bed file for each 1cM window
rule make_bed_file_for_windows:
    input:
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt"
    output:
        expand("ancestry_by_r/results/BED_1cM/{WINDOW}.bed", WINDOW = windows_1cM)
    params:
        p = "med2",
        prefix_all = prefix_all
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = 5,
        mem = 2
    script:
        "make_bed_4_windows.R"

## find_SNPs_in_window: creates a GL file for each 1cM window using bedtools
# To accomplish this, I use an awk split file; first mapping the window label onto the GL line,
# then sending lines into each window-named file based on their 1cM window label
rule find_SNPs_in_window:
    input:
        gl = "global_ancestry/results/thinnedSNPs/" + prefix_all + "/whole_genome.beagle.gz",
        bed = "ancestry_by_r/results/BED_1cM/{WINDOW}.bed",
        genome = ref_chr
    output:
        "ancestry_by_r/results/GL_1cM/" + prefix_all + "/{WINDOW}.beagle.gz"
    params:
        p = "med2",
        prefix_all = prefix_all
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = lambda wildcards, attempt: attempt * 20,
        mem = lambda wildcards, attempt: attempt * 8
    shell:
        # get header and then append all the SNPs found within the window specified by the bed file
        "./ancestry_by_r/find_SNPs_in_window.sh {input.gl} {input.bed} {input.genome} {output}"
        # zcat {input.gl} | head -n 1 | gzip > {output}
        # zcat {input.gl} | \
        # awk '{{split($1, a, "_"); print a[1]"\\t"a[2]-1"\\t"a[2]"\\t"$0}}' | tail -n +2 | \
        # bedtools intersect -a stdin -b {input.bed} -wa -sorted -g {input.genome} | \
        # cut -f4- | gzip >> {output}

## make_bootstrap_GL_file: creates a new beagle GL file for a bootstrap sample by including SNPs within the sampled windows (with replacement)
rule make_bootstrap_GL_file:
    input:
        "global_ancestry/results/thinnedSNPs/" + prefix_all + "/whole_genome.beagle.gz",
        "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/boot{BOOT}.list",
        expand("ancestry_by_r/results/GL_1cM/" + prefix_all + "/{WINDOW}.beagle.gz", WINDOW = windows_1cM)
    output:
        "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/boot{BOOT}.beagle.gz"
    params:
        p = "med2",
        prefix_all = prefix_all,
        gl = lambda wildcards, input: input[0],
        sample = lambda wildcards, input: input[1]
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = lambda wildcards, attempt: attempt * 20,
        mem = lambda wildcards, attempt: attempt * 8
    shell:
        "./ancestry_by_r/make_bootstrap_GL_file.sh {params.gl} {params.sample} {params.prefix_all} {output}"

## run_bootstrap_NGSAdmix: runs NGSAdmix for a bootstrap sample
rule run_bootstrap_NGSAdmix:
    input:
        gl = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/boot{BOOT}.beagle.gz"
    output:
        admix = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/K2/boot{BOOT}.qopt"
    params:
        p = "med2",
        prefix_all = prefix_all,
        k = 2
    shadow:
         "minimal"
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = lambda wildcards, attempt: attempt * 30,
        mem = lambda wildcards, attempt: attempt * 4
    threads:
        1
    shell:
        """
        NGSadmix -likes {input.gl} \
        -K {params.k} -P {threads} \
        -o "ancestry_by_r/results/bootstrap_1cM/{params.prefix_all}/{wildcards.FEATURE}5_{wildcards.r}/K{params.k}/boot{wildcards.BOOT}"
        """

## label_k_anc: defines which of K ancestries is 'mexicana' based on allopatric reference panels
rule label_k_anc:
    input:
        admix = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/K2/boot{BOOT}.qopt",
        meta = "samples/HILO_MAIZE55_meta.RData"
    output:
        anc = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/K2/boot{BOOT}.anc"
    params:
        p = "med2",
        k = 2
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = 5,
        mem = 2
    script:
        "label_k_ancestries.R"

## plot_bootstrap_anc_by_r: plots bootstrap results for global ancestry by recombination rate
rule plot_bootstrap_anc_by_r:
    input:
        "samples/HILO_MAIZE55_meta.RData", # can't have only some named inputs; can use [[1]] to access in R
        "colors.R",
        "ancestry_by_r/results/map_pos_1cM_windows.txt",
        expand("ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/K2/boot{BOOT}.anc",
        r = [1, 2, 3, 4, 5], FEATURE = ["r", "cd"], BOOT = list(range(0, 101)))
    output:
        png_symp = "ancestry_by_r/plots/K2_by_r_bootstrap_sympatric_only.png",
        png_symp_allo = "ancestry_by_r/plots/K2_by_r_bootstrap_sympatric_and_allopatric.png",
        png_facet_r = "ancestry_by_r/plots/K2_by_r_bootstrap_lm_elevation_facet_r.png",
        png_color_elev = "ancestry_by_r/plots/K2_by_r_bootstrap_lm_elevation_color_elev.png"
    params:
        p = "med2",
        k = 2,
        prefix_all = prefix_all,
        meta = "samples/HILO_MAIZE55_meta.RData",
        colors = "colors.R",
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt"
    conda:
         "../envs/environment.yaml"
    resources:
         time_min = 15,
         mem = 2
    script:
         "plot_bootstrap_NGSadmix.R"
