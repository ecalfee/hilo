## ancestry_by_r/Snakefile: pipeline to get global ancestry estimates by recombination quintile (and bootstrap results)

workdir: path_hilo
# note: working directory is hilo/ and all file inputs/outputs below are relative to that working directory

## make_coding_bed: makes a bed file of coding regions ('CDS') from gff3 file. merges overlapping CDS and sorts results by genome order.
rule make_coding_bed:
    input:
        annotations = ref_anno,
        genome = ref_chr
    output:
        bed = "data/refMaize/geneAnnotations/Zea_mays.B73_RefGen_v4.41.chr.CDS.bed"
    params:
        p = "med2"
    shadow:
         "minimal"
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = 5,
        mem = 4
    shell:
        """
        grep -v '^#' {input.annotations} | awk -v OFS='\\t' '{{print $1,$4,$5,$3}}' |\\
        grep 'CDS' | grep -v '^Mt' | grep -v '^Pt' |\\
        bedtools sort -faidx {input.genome} -i stdin |\\
        bedtools merge -i stdin -c 4 -o distinct > {output}
        """

## define_1cM_windows: divides genome into 1cM windows
rule define_1cM_windows:
    input:
        rmap = rmap_ext,
        genome = ref_chr,
        cds = "data/refMaize/geneAnnotations/Zea_mays.B73_RefGen_v4.41.chr.CDS.bed"
    output:
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt"
    params:
        p = "med2"
    shadow:
         "minimal"
    conda:
         "../envs/environment.yaml"
    resources:
         time_min = 15,
         mem = 2
    script:
         "define_1cM_windows_from_map.R" # define_bootstrap_windows_from_map.R

## sample_bootstrap_1cM: makes bootstrap (i.e. with replacement) samples of 1cM windows within recombination rate quintiles
rule sample_bootstrap_1cM:
    input:
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt"
    output: # FEATURE is recombination rate cM/Mb (r), coding bp/cM (cd), or frac coding bp (frac)
        expand("ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{{FEATURE}}5_{r}/boot{BOOT}.list",
        r = [1, 2, 3, 4, 5], BOOT = list(range(0,101))) # 5 recombination rate quintiles, '0' for original sample and 1-100 bootstrap samples
    params:
        p = "med2",
        n = 100, # 100 bootstraps
        prefix_all = prefix_all,
        feature = lambda wildcards: wildcards.FEATURE
    conda:
         "../envs/environment.yaml"
    resources:
         time_min = 15,
         mem = 2
    script:
         "sample_windows_4_bootstrap.R"

## make_bed_files_for_windows: makes a separate bed file for each 1cM window
rule make_bed_file_for_windows:
    input:
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt"
    output:
        expand("ancestry_by_r/results/BED_1cM/{WINDOW}.bed", WINDOW = windows_1cM)
    params:
        p = "med2",
        prefix_all = prefix_all
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = 5,
        mem = 2
    script:
        "make_bed_4_windows.R"

## find_SNPs_in_window: creates a GL file for each 1cM window using bedtools
# To accomplish this, I use an awk split file; first mapping the window label onto the GL line,
# then sending lines into each window-named file based on their 1cM window label
rule find_SNPs_in_window:
    input:
        gl = "global_ancestry/results/thinnedSNPs/" + prefix_all + "/whole_genome.beagle.gz",
        bed = "ancestry_by_r/results/BED_1cM/{WINDOW}.bed",
        genome = ref_chr
    output:
        "ancestry_by_r/results/GL_1cM/" + prefix_all + "/{WINDOW}.beagle.gz"
    params:
        p = "med2",
        prefix_all = prefix_all
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = lambda wildcards, attempt: attempt * 20,
        mem = lambda wildcards, attempt: attempt * 8
    shell:
        # get header and then append all the SNPs found within the window specified by the bed file
        "./ancestry_by_r/find_SNPs_in_window.sh {input.gl} {input.bed} {input.genome} {output}"
        # zcat {input.gl} | head -n 1 | gzip > {output}
        # zcat {input.gl} | \
        # awk '{{split($1, a, "_"); print a[1]"\\t"a[2]-1"\\t"a[2]"\\t"$0}}' | tail -n +2 | \
        # bedtools intersect -a stdin -b {input.bed} -wa -sorted -g {input.genome} | \
        # cut -f4- | gzip >> {output}

## make_bootstrap_GL_file: creates a new beagle GL file for a bootstrap sample by including SNPs within the sampled windows (with replacement)
rule make_bootstrap_GL_file:
    input:
        "global_ancestry/results/thinnedSNPs/" + prefix_all + "/whole_genome.beagle.gz",
        "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/boot{BOOT}.list",
        expand("ancestry_by_r/results/GL_1cM/" + prefix_all + "/{WINDOW}.beagle.gz", WINDOW = windows_1cM)
    output:
        "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/boot{BOOT}.beagle.gz"
    params:
        p = "med2",
        prefix_all = prefix_all,
        gl = lambda wildcards, input: input[0],
        sample = lambda wildcards, input: input[1]
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = lambda wildcards, attempt: attempt * 20,
        mem = lambda wildcards, attempt: attempt * 8
    shell:
        "./ancestry_by_r/make_bootstrap_GL_file.sh {params.gl} {params.sample} {params.prefix_all} {output}"

## run_bootstrap_NGSAdmix: runs NGSAdmix for a bootstrap sample
rule run_bootstrap_NGSAdmix:
    input:
        gl = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/boot{BOOT}.beagle.gz"
    output:
        admix = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/K2/boot{BOOT}.qopt"
    params:
        p = "med2",
        prefix_all = prefix_all,
        k = 2
    shadow:
         "minimal"
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = lambda wildcards, attempt: attempt * 30,
        mem = lambda wildcards, attempt: attempt * 4
    threads:
        1
    shell:
        """
        NGSadmix -likes {input.gl} \
        -K {params.k} -P {threads} \
        -o "ancestry_by_r/results/bootstrap_1cM/{params.prefix_all}/{wildcards.FEATURE}5_{wildcards.r}/K{params.k}/boot{wildcards.BOOT}"
        """

## label_k_anc: defines which of K ancestries is 'mexicana' based on allopatric reference panels
rule label_k_anc:
    input:
        admix = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/K2/boot{BOOT}.qopt",
        meta = "samples/HILO_MAIZE55_meta.RData"
    output:
        anc = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_{r}/K2/boot{BOOT}.anc"
    params:
        p = "med2",
        k = 2
    conda:
         "../envs/environment.yaml"
    resources:
        time_min = 5,
        mem = 2
    script:
        "label_k_ancestries.R"

## summarise_bootstrap_anc_by_r: summarises bootstrap results for global ancestry by genomic quintiles
rule summarise_bootstrap_anc_by_r:
    input:
        "samples/HILO_MAIZE55_meta.RData", # can't have only some named inputs; can use [[1]] to access in R
        "ancestry_by_r/results/map_pos_1cM_windows.txt",
        expand("ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{{FEATURE}}5_{r}/K2/boot{BOOT}.anc",
        r = [1, 2, 3, 4, 5], BOOT = list(range(0, 101)))
    output:
        rdata = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/{FEATURE}5_K2.Rdata"
    params:
        p = "med2",
        k = 2,
        prefix_all = prefix_all,
        feature = lambda wildcards: wildcards.FEATURE,
        meta = "samples/HILO_MAIZE55_meta.RData",
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt",
        alpha = 0.1 # use 90% confidence intervals for bootstrap
    conda:
         "../envs/environment.yaml"
    resources:
         time_min = 15,
         mem = 2
    script:
         "summarise_bootstrap_NGSadmix.R"

## map_local_anc_onto_1cM_windows: maps local ancestry results onto 1cM genomic windows based on ancestry tracts bed file
rule map_local_anc_onto_1cM_windows:
    input:
        anc = "local_ancestry/results/ancestry_hmm/" + prefix_all + "/Ne{Ne}_{YESNO}Boot/anc/{POP}.anc.freq",
        tracts = "local_ancestry/results/thinnedSNPs/" + prefix_all + "/whole_genome.bed", # defines ancestry tracts
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt" # 1cM windows
    output:
        bed = "ancestry_by_r/results/local_anc_1cM/" + prefix_all + "/Ne{Ne}_{YESNO}Boot/{POP}.bed"
    params:
        p = "med2"
    conda:
        "../envs/environment.yaml"
    resources:
        time_min = 10,
        mem = 2
    shell:
        """
        paste {input.tracts} {input.anc} | \\
        bedtools intersect -b {input.windows} -a stdin | \\
        bedtools sort | \\
        bedtools map -a stdin -b {input.windows} -c 4 -o distinct > {output.bed}
        """

## map_sites_onto_1cM_windows: maps sites onto 1cM windows
rule map_sites_onto_1cM_windows:
    input:
        tracts = "local_ancestry/results/thinnedSNPs/" + prefix_all + "/whole_genome.bed", # defines ancestry tracts
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt" # 1cM windows
    output:
        bed = "ancestry_by_r/results/local_anc_1cM/" + prefix_all + "/ancestry_hmm_sites.bed"
    params:
        p = "med2"
    conda:
        "../envs/environment.yaml"
    resources:
        time_min = 10,
        mem = 2
    shell:
        """
        awk {input.tracts} -v OFS='\\t' '{{print $1,$2-1,$2}}' | \\
        bedtools map -b {input.windows} -a stdin | \\
        bedtools sort > {output.bed}
        """

## summarise_local_anc_by_1cM: summarises mean local ancestry results by 1cM genomic windows
rule summarise_local_anc_by_1cM:
    input:
        bed = "ancestry_by_r/results/local_anc_1cM/" + prefix_all + "/Ne{Ne}_{YESNO}Boot/{POP}.bed",
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt" # 1cM windows
    output:
        summary = "ancestry_by_r/results/local_anc_1cM/" + prefix_all + "/Ne{Ne}_{YESNO}Boot/{POP}.anc.wind"
    params:
        p = "bigmemm",
        pop = lambda wildcards: wildcards.POP
    conda:
        "../envs/environment.yaml"
    resources:
        time_min = 5,
        mem = 2
    script:
        "summarise_local_anc_by_1cM.R"

## input_abba_baba: creates input size and bam_list for running abba baba (f4) calcs
rule input_abba_baba:
    input:
        parv_bams = "samples/ALL_byPop/parv_bams.list",
        mex_bams = "samples/ALL_byPop/allopatric_mexicana_bams.list",
        x_bams = "samples/ALL_byPop/{POP}_bams.list",
        trip_bams = "samples/ALL_byPop/trip_bams.list"
    output:
        bam_list = "ancestry_by_r/results/f4/{POP}_bams.list",
        pops_size = "ancestry_by_r/results/f4/{POP}.size"
    params:
        p = "med2"
    resources:
        time_min = 1,
        mem = 1
    shell:
        """
        cat {input.parv_bams} {input.mex_bams} {input.x_bams} {input.trip_bams} > {output.bam_list}
        < {input.parv_bams} wc -l > {output.pops_size}
        < {input.mex_bams} wc -l >> {output.pops_size}
        < {input.x_bams} wc -l >> {output.pops_size}
        < {input.trip_bams} wc -l >> {output.pops_size}
        """

## get_region_from_bed(): helper function to extract region in format chr:start-end from a single region bed file
def get_region_from_bed(window):
    with open("ancestry_by_r/results/BED_1cM/" + window + ".bed") as f:
        line1 = f.readline()
        line2 = f.readline()
        row = line2.split("\t")
    return row[0] + ":" + row[1] + "-" + row[2]

## get_size_region_from_bed(): helper function to extract size of a region as an integer (# bp start-end) from a single region bed file
def get_size_region_from_bed(window):
    with open("ancestry_by_r/results/BED_1cM/" + window + ".bed") as f:
        line1 = f.readline()
        line2 = f.readline()
        row = line2.split("\t")
    return (int(row[2]) - int(row[1]))/1000000 # units Mbp

## do_abba_baba: runs angsd abba_baba2 to get f4 statistic for 1 genomic window
# output file has all possible population orders .. will later extract f4(parv, mex; x, trip)
rule do_abba_baba:
    input:
        bams = all_bams_parv_trip, # all input bams
        bais = [bam + ".bai" for bam in all_bams_parv_trip], # all input bam indexes
        bam_list = "ancestry_by_r/results/f4/{POP}_bams.list",
        bed_window = "ancestry_by_r/results/BED_1cM/{WINDOW}.bed",
        pops_size = "ancestry_by_r/results/f4/{POP}.size"
    output:
        abbababa = "ancestry_by_r/results/f4/{POP}/{WINDOW}.abbababa2",
        sample_depth = "ancestry_by_r/results/f4/{POP}/{WINDOW}.depthSample",
        global_depth = "ancestry_by_r/results/f4/{POP}/{WINDOW}.depthGlobal"
    params:
        p = "med2",
        out_prefix = "ancestry_by_r/results/f4/{POP}/{WINDOW}",
        region = lambda wildcards: get_region_from_bed(wildcards.WINDOW)
    shadow:
        "minimal"
    resources:
        time_min = lambda wildcards, attempt: attempt * 30 + int(get_size_region_from_bed(wildcards.WINDOW) * 3.5), # 1/2 hour to 4 hours for attempt 1
        mem = lambda wildcards, attempt: [8, 16, 40][attempt - 1] # 8G, 16G or 40G
    shell:
        "angsd -out {params.out_prefix} "
        "-doAbbababa2 1 "
        "-r {params.region} "
        "-bam {input.bam_list} "
        "-sizeFile {input.pops_size} "
        "-remove_bads 1 -minMapQ 30 -minQ 20 "
        "-doCounts 1 -doDepth 1 "
        "-maxDepth 10000 "
        "-useLast 1 "
        "-blockSize 60000000 "
        "-checkBamHeaders 0"

# what is the size of the largest 1cM window? set chunk size larger than that.
# biggest 1cM window is 54024630bp, so I set chunck size to 60Mbp
# how should I input regions?
# -doAbbababa2 options: -maxDepth=max depth of each site allowed (default 100)
# -sizeFile = file with sizes of the populations
# -doCounts 1 = make counts (required)
# -useLast 1 = use the last group of bam files as outgroup (tripsacum)

## subsample_group: takes a random subsample (no-repeats) of bams from a group of bams
# rule subsample_group:
#     input:
#         all_bams = "samples/ALL_byPop/{GROUP}_bams.list"
#     output:
#         sub_bams = "samples/ALL_byPop/{GROUP}_subsample{SUBSAMPLE}_bams.list"
#     params:
#         p = "med2",
#         i = "{SUBSAMPLE}"
#     resources:
#         time_min = 1,
#         mem = 1
#     shell:
#         shuf -n {params.i} {input.all_bams} > {output.sub_bams}


# ABBA BABA is very intensive (!), I will subsample to just 10 individuals for the high coverage populations:
## input_abba_baba_subsample: creates input size and bam_list for running abba baba (f4) calcs
# subsamples to just 10 ind's for high coverage parv and allopatric_maize populations
# rule input_abba_baba_subsample:
#     input:
#         parv_bams = "samples/ALL_byPop/parv_subsample10_bams.list",
#         mex_bams = "samples/ALL_byPop/allopatric_mexicana_bams.list",
#         x_bams = "samples/ALL_byPop/{POP}_bams.list",
#         trip_bams = "samples/ALL_byPop/trip_bams.list"
#     output:
#         bam_list = "ancestry_by_r/results/f4_subsample/{POP}_bams.list",
#         pops_size = "ancestry_by_r/results/f4_subsample/{POP}.size"
#     params:
#         p = "med2",
#     resources:
#         time_min = 1,
#         mem = 1
#     shell:
#         """
#         cat {input.parv_bams} {input.mex_bams} {input.x_bams} {input.trip_bams} > {output.bam_list}
#         < {input.parv_bams} wc -l > {output.pops_size}
#         < {input.mex_bams} wc -l >> {output.pops_size}
#         < {input.x_bams} wc -l >> {output.pops_size}
#         < {input.trip_bams} wc -l >> {output.pops_size}
#         """

## do_abba_baba_subsample: runs angsd abba_baba2 to get f4 statistic for 1 genomic window
# output file has all possible population orders .. will later extract f4(parv, mex; x, trip)
# subsamples to just 10 ind's for high coverage parv and allopatric_maize populations
# rule do_abba_baba_subsample:
#     input:
#         bams = all_bams_parv_trip, # all input bams
#         bais = [bam + ".bai" for bam in all_bams_parv_trip], # all input bam indexes
#         bam_list = "ancestry_by_r/results/f4_subsample/{POP}_bams.list",
#         bed_window = "ancestry_by_r/results/BED_1cM/{WINDOW}.bed",
#         pops_size = "ancestry_by_r/results/f4_subsample/{POP}.size"
#     output:
#         abbababa = "ancestry_by_r/results/f4_subsample/{POP}/{WINDOW}.abbababa2",
#         sample_depth = "ancestry_by_r/results/f4_subsample/{POP}/{WINDOW}.depthSample",
#         global_depth = "ancestry_by_r/results/f4_subsample/{POP}/{WINDOW}.depthGlobal"
#     params:
#         p = "med2",
#         out_prefix = "ancestry_by_r/results/f4_subsample/{POP}/{WINDOW}",
#         region = lambda wildcards: get_region_from_bed(wildcards.WINDOW)
#     shadow:
#         "minimal"
#     resources:
#         time_min = lambda wildcards, attempt: attempt * 2 * 60,
#         mem = 4
#     shell:
#         "angsd -out {params.out_prefix} "
#         "-doAbbababa2 1 "
#         "-r {params.region} "
#         "-bam {input.bam_list} "
#         "-sizeFile {input.pops_size} "
#         "-remove_bads 1 -minMapQ 30 -minQ 20 "
#         "-doCounts 1 -doDepth 1 "
#         "-maxDepth 10000 "
#         "-useLast 1 "
#         "-blockSize 60000000 "
#         "-checkBamHeaders 0"


## plot_bootstrap_anc_by_r: plots bootstrap results for global & local ancestry by recombination rate
rule plot_bootstrap_anc_by_r:
    input:
        colors = "colors.R",
        meta = "samples/HILO_MAIZE55_meta.RData",
        windows = "ancestry_by_r/results/map_pos_1cM_windows.txt",
        inv_file = "data/refMaize/inversions/knownInv_v4_coord.txt",
        r5 = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/r5_K2.Rdata",
        cd5 = "ancestry_by_r/results/bootstrap_1cM/" + prefix_all + "/cd5_K2.Rdata",
        local_anc = ["ancestry_by_r/results/local_anc_1cM/" + prefix_all + "/Ne10000_yesBoot/" + POP + ".anc.wind" for POP in symp_pops]
    output:
        png_r5_symp = "ancestry_by_r/plots/K2_by_r_bootstrap_sympatric_only.png",
        png_r5_symp_allo = "ancestry_by_r/plots/K2_by_r_bootstrap_sympatric_and_allopatric.png",
        png_cd5_symp = "ancestry_by_r/plots/K2_by_cd_bootstrap_sympatric_only.png",
        png_cd5_symp_allo = "ancestry_by_r/plots/K2_by_cd_bootstrap_sympatric_and_allopatric.png",
        png_cor_r_cd = "ancestry_by_r/plots/corr_r_cd_1cM.png",
        png_cor_r_frac = "ancestry_by_r/plots/corr_r_frac_1cM.png",
        png_facet_r5 = "ancestry_by_r/plots/K2_by_r_bootstrap_lm_elevation_facet_r.png",
        png_color_elev_r5 = "ancestry_by_r/plots/K2_by_r_bootstrap_lm_elevation_color_elev.png",
        png_r5_local_anc = "ancestry_by_r/plots/local_anc_by_r_sympatric_only.png",
        png_cd5_local_anc = "ancestry_by_r/plots/local_anc_by_cd_sympatric_only.png",
        png_boot_cor_local_anc_bp = "ancestry_by_r/plots/boot_cor_local_anc_bp.png",
        png_boot_cor_local_anc_r5 = "ancestry_by_r/plots/boot_cor_local_anc_r5.png"

    params:
        p = "med2",
        alpha = 0.05,
        dir_anc = "ancestry_by_r/results/local_anc_1cM/" + prefix_all + "/Ne10000_yesBoot"
    conda:
         "../envs/environment.yaml"
    resources:
         time_min = 5,
         mem = 4
    script:
         "plot_bootstrap_NGSadmix.R"
